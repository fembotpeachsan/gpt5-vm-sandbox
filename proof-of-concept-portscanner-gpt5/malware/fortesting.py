#!/usr/bin/env bash
# shscan.sh — simple TCP port scanner (shell-only)
# Usage:
#   ./shscan.sh -h <host> [-p <start:end>] [-t <seconds>] [-c <concurrency>]
# Examples:
#   ./shscan.sh -h 192.168.1.10
#   ./shscan.sh -h example.com -p 1:65535 -t 1 -c 200
#
# Notes:
# - TCP connect scan only. Use on systems you own or are authorized to test.
# - Prefers `nc` (netcat). Falls back to bash /dev/tcp with `timeout` if present.
# - Concurrency uses xargs -P when available; otherwise runs serially.

set -euo pipefail

HOST=""
RANGE_START=1
RANGE_END=1024
TIMEOUT_SEC=1
CONC=100

die() { echo "error: $*" >&2; exit 1; }

# -------- arg parse --------
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--host) HOST="${2:-}"; shift 2 ;;
    -p|--ports)
      IFS=':' read -r RANGE_START RANGE_END <<<"${2:-}"
      [[ -n "${RANGE_START:-}" && -n "${RANGE_END:-}" ]] || die "invalid port range"
      shift 2 ;;
    -t|--timeout) TIMEOUT_SEC="${2:-}"; shift 2 ;;
    -c|--concurrency) CONC="${2:-}"; shift 2 ;;
    -?|--help|-help|help)
      sed -n '1,40p' "$0"; exit 0 ;;
    *) die "unknown arg: $1" ;;
  esac
done

[[ -n "$HOST" ]] || die "host is required (-h)."
[[ "$RANGE_START" =~ ^[0-9]+$ && "$RANGE_END" =~ ^[0-9]+$ && $RANGE_START -ge 1 && $RANGE_END -le 65535 && $RANGE_START -le $RANGE_END ]] \
  || die "invalid port range: $RANGE_START:$RANGE_END"

HAVE_NC=0
if command -v nc >/dev/null 2>&1; then
  # BusyBox and OpenBSD nc differ; use common flags: -z (scan), -w timeout, -G on mac/BSD for read timeout
  HAVE_NC=1
fi
HAVE_TIMEOUT=0
if command -v timeout >/dev/null 2>&1; then
  HAVE_TIMEOUT=1
fi

scan_nc() {
  local host="$1" port="$2" to="$3"
  # Try GNU-style: -z -w; fall back to BSD macOS: -z -G
  if nc -z -w "$to" "$host" "$port" >/dev/null 2>&1; then
    echo "OPEN tcp $port"
  elif nc -z -G "$to" "$host" "$port" >/dev/null 2>&1; then
    echo "OPEN tcp $port"
  fi
}

scan_bash_tcp() {
  local host="$1" port="$2" to="$3"
  if (( HAVE_TIMEOUT )); then
    if timeout "$to" bash -c "exec 3<>/dev/tcp/$host/$port" >/dev/null 2>&1; then
      echo "OPEN tcp $port"
    fi
  else
    # No `timeout` available — may block longer on closed ports.
    if bash -c "exec 3<>/dev/tcp/$host/$port" >/dev/null 2>&1; then
      echo "OPEN tcp $port"
    fi
  fi
}

export -f scan_nc scan_bash_tcp
export HOST TIMEOUT_SEC HAVE_NC HAVE_TIMEOUT

echo "Target: $HOST"
echo "Ports : $RANGE_START-$RANGE_END"
echo "Mode  : $([[ $HAVE_NC -eq 1 ]] && echo nc || echo /dev/tcp)$([[ $HAVE_TIMEOUT -eq 1 ]] && echo " + timeout" || true)"
echo "Conc. : $CONC"
echo

generate_ports() {
  local i
  for (( i=RANGE_START; i<=RANGE_END; i++ )); do
    echo "$i"
  done
}

runner() {
  local port="$1"
  if (( HAVE_NC )); then
    scan_nc "$HOST" "$port" "$TIMEOUT_SEC"
  else
    scan_bash_tcp "$HOST" "$port" "$TIMEOUT_SEC"
  fi
}

export -f runner

if command -v xargs >/dev/null 2>&1; then
  # parallel scan using xargs -P
  generate_ports | xargs -P "$CONC" -n 1 -I{} bash -c 'runner "$@"' _ {}
else
  # serial fallback
  while read -r p; do runner "$p"; done < <(generate_ports)
fi | sort -n -k3
